package inky.framework.components.listViews.scrollableList{	import inky.framework.collections.*;	import inky.framework.components.scrollPane.views.BaseScrollPane;	import inky.framework.components.scrollBar.ScrollPolicy;	import inky.framework.components.listViews.IListView;//	import inky.framework.components.listViews.IListItemView;	import inky.framework.components.scrollPane.views.IScrollPane;	import inky.framework.controls.*;	import inky.framework.display.IDisplayObject;	import inky.framework.components.scrollBar.events.ScrollEvent;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 *	 *  		 * @author Eric Eldredge	 * @author Rich Perez	 * @author Matthew Tretter	 *	 * @langversion ActionScript 3	 * @playerversion Flash 9.0.0	 *		 */	public class ScrollableList extends BaseScrollPane implements IListView	{		private static var HORIZONTAL:String = "horizontal"; // Should be in another class.		private static var VERTICAL:String = "vertical";				private var __contentContainer:DisplayObjectContainer;		private var _defaultListItemSize:Number;		private var _model:IList;		private var _listItems:Object;		private var _itemViewClass:Class;		private var _numItemsInitiallyVisible:uint;		private var _orientation:String;		private var _widthOrHeight:String;		private var _xOrY:String;		public function ScrollableList()		{			this._init();		}		private function _init():void		{			if (this.horizontalScrollBar && this.verticalScrollBar)			{				throw new Error("A ScrollableList can have either a horizontal or vertical scroll bar, but not both");			}						if (this.horizontalScrollBar)			{				this._orientation = HORIZONTAL;				this._widthOrHeight = "width";				this._xOrY = "x";			}			else			{				this._orientation = VERTICAL;				this._widthOrHeight = "height";				this._xOrY = "y";			}			this._defaultListItemSize = 0;			this._listItems = {};			this.__contentContainer = this.getContentContainer();//			this.source = this.getContentContainer();			this[this._orientation + 'LineScrollSize'] = 1;		}		/**		 * @inheritDoc		 */		public function get model():IList		{			return this._model;		}		/**		 * @private		 */		public function set model(model:IList):void		{			this._model = model;			this._setContent();		}		/**		 * @inheritDoc		 */		public function get itemViewClass():Class		{			return this._itemViewClass;		}		/**		 * @private		 */		public function set itemViewClass(itemViewClass:Class):void		{			this._itemViewClass = itemViewClass;		}		private function _setContent():void		{			this.addEventListener(Event.ENTER_FRAME, this._setContentNow);		}						private function _setContentNow(e:Event):void		{			e.currentTarget.removeEventListener(e.type, arguments.callee);			this._clearContent();			if (this._model == null) return;			if (this._itemViewClass == null)			{				throw new Error("itemViewClass is not set!");			}			this[this._orientation + 'ScrollBar'].minScrollPosition = 0			this._updateContent(0, true);			this.update();		}		private function _clearContent():void		{			while (this.__contentContainer.numChildren)			{				this.__contentContainer.removeChildAt(0);			}		}		/**		 * @inheritDoc		 */			override public function update():void		{			if (model)			{				if (this[this._orientation + "ScrollBar"])				{					this[this._orientation + "ScrollBar"].maxScrollPosition = this.model.length - this._numItemsInitiallyVisible + 1;				}			}		}		override protected function scrollHandler(e:ScrollEvent):void		{			var pos:Number = Math.round(this[this._orientation + "ScrollPosition"]);			var newPos:Object = {x: this.__contentContainer.x, y: this.__contentContainer.y};			var mask:DisplayObject = this.getScrollMask();						if (!isNaN(pos))			{//				this._updateContent(pos);				if (this.model != null)					newPos[this._xOrY] = Math.min(0, -Math.min(this._defaultListItemSize * pos, this._defaultListItemSize * this.model.length - mask[this._widthOrHeight]));			}			this.moveContent(newPos.x, newPos.y);		}private var _firstVisibleItemIndex:int;private function _updateContent(startIndex:int, firstTime:Boolean = false):void{	/*if (!firstTime && (startIndex == this._firstVisibleItemIndex))	{		// Already showing the correct units.		return;	}*/	var listItem:Object;	var tmp:Object;	var index:int = startIndex;	var roomForMore:Boolean = true;	var mask:DisplayObject = this.getScrollMask();	var maskSize:Number = mask[this._widthOrHeight];	var maskY:Number = mask[this._xOrY];	var y:Number = startIndex * this._defaultListItemSize;	var container:DisplayObjectContainer = this.getContentContainer();	var usedItems:Array = [];	while ((index < this.model.length) && (y + container.y < maskSize + mask.y))	{		listItem = this._listItems[index];				if (listItem == null)		{			// Find one to reuse			for (var j:int = 1; j < this.model.length; j++)			{				var k:int = (this.model.length - j + index + this.model.length) % this.model.length;				tmp = this._listItems[k];				if (tmp != null)				{					var isUsed:Boolean = usedItems.indexOf(tmp) != -1;										if (!isUsed)					{						var p:Point = mask.globalToLocal(tmp.localToGlobal(new Point(0, 0)));						var bottom:Number = p[this._xOrY] + tmp[this._widthOrHeight];						listItem = tmp;						delete this._listItems[k];						break;					}				}			}					// If no item could be reused, make a new one.			if (listItem == null)			{				listItem = new this._itemViewClass();				this.__contentContainer.addChild(listItem as DisplayObject);				this._defaultListItemSize = listItem[this._widthOrHeight];			}						listItem.model = this.model.getItemAt(index);			this._listItems[index] = listItem;		}		usedItems[index] = listItem;		y += listItem[this._widthOrHeight];		listItem[this._xOrY] = this._defaultListItemSize * index;		index++;	}	var contentSize:Number = listItem[this._xOrY] + listItem[this._widthOrHeight];	this[this._orientation + "ScrollBar"].enabled = this.__contentContainer[this._widthOrHeight] > mask[this._widthOrHeight];	if (this[this._orientation + "ScrollPolicy"] == ScrollPolicy.AUTO)	{		this[this._orientation + "ScrollBar"].visible = this[this._orientation + "ScrollBar"].enabled;	}	else	{		this[this._orientation + "ScrollBar"].visible = this[this._orientation + "ScrollPolicy"] == ScrollPolicy.ON;	}// Hide the unused items.for each (listItem in this._listItems){//	listItem.visible = usedItems.indexOf(listItem) != -1;}	if (firstTime)	{		var numItemsInitiallyVisible = index - this[this._orientation + "ScrollPosition"];		this[this._orientation + "ScrollBar"].pageSize = numItemsInitiallyVisible;		this[this._orientation + "PageScrollSize"] = numItemsInitiallyVisible - 1;		this._numItemsInitiallyVisible = numItemsInitiallyVisible;	}	this._firstVisibleItemIndex = startIndex;	}		/**		 *		 * Updates the contents of the container based on its position.		 *				 */		protected function updateStuff():void		{			var container:DisplayObjectContainer = this.getContentContainer();			var mask:DisplayObject = this.getScrollMask();			// Get the index of the first visible item.			var firstVisibleItemIndex:int = 0;			var combinedSize:Number = 0;			var y:Number = container.y;			while ((y += this._defaultListItemSize) < mask.y)			{				firstVisibleItemIndex++;			}			this._updateContent(firstVisibleItemIndex);		}		override protected function moveContent(x:Number, y:Number):void		{			super.moveContent(x, y);			this.updateStuff();		}	}}