package inky.framework.components.listViews.scrollableList{	import inky.framework.collections.*;	import inky.framework.components.scrollPane.views.BaseScrollPane;	import inky.framework.components.scrollBar.ScrollPolicy;	import inky.framework.components.listViews.IListView;//	import inky.framework.components.listViews.IListItemView;	import inky.framework.components.scrollPane.views.IScrollPane;	import inky.framework.controls.*;	import inky.framework.display.IDisplayObject;	import inky.framework.components.scrollBar.events.ScrollEvent;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 *	 *  		 * @author Eric Eldredge	 * @author Rich Perez	 * @author Matthew Tretter	 *	 * @langversion ActionScript 3	 * @playerversion Flash 9.0.0	 *		 */	public class ScrollableList extends BaseScrollPane implements IListView	{		private static var HORIZONTAL:String = "horizontal"; // Should be in another class.		private static var VERTICAL:String = "vertical";				private var __contentContainer:DisplayObjectContainer;		private var _model:IList;		private var _listItems:Object;		private var _itemViewClass:Class;		private var _numItemsFinallyVisible:uint;  // The number of items visible at max scroll position.		private var _orientation:String;		private var _widthOrHeight:String;		private var _xOrY:String;		private var _firstVisibleItemIndex:int;		private var _unusedItems:Array;		private var _positionCache:Array;private var _sizeCache:Array;		public function ScrollableList()		{			this._init();		}		private function _init():void		{			if (this.horizontalScrollBar && this.verticalScrollBar)			{// FIXME: should work with both, in case for example items in a vertically oriented list are too wide.				throw new Error("A ScrollableList can have either a horizontal or vertical scroll bar, but not both");			}						if (this.horizontalScrollBar)			{				this._orientation = HORIZONTAL;				this._widthOrHeight = "width";				this._xOrY = "x";			}			else			{				this._orientation = VERTICAL;				this._widthOrHeight = "height";				this._xOrY = "y";			}			this.__contentContainer = this.getContentContainer();			this[this._orientation + 'LineScrollSize'] = 1;		}		/**		 * @inheritDoc		 */		public function get model():IList		{			return this._model;		}		/**		 * @private		 */		public function set model(model:IList):void		{			this._model = model;			this._setContent();		}		/**		 * @inheritDoc		 */		public function get itemViewClass():Class		{			return this._itemViewClass;		}		/**		 * @private		 */		public function set itemViewClass(itemViewClass:Class):void		{			this._itemViewClass = itemViewClass;		}		private function _setContent():void		{			this._positionCache = [];			this._unusedItems = [];			this._sizeCache = [];			this._listItems = {};			this.addEventListener(Event.ENTER_FRAME, this._setContentNow);		}						private function _setContentNow(e:Event):void		{			e.currentTarget.removeEventListener(e.type, arguments.callee);			this._clearContent();			if (this._model == null) return;			if (this._itemViewClass == null)			{				throw new Error("itemViewClass is not set!");			}			this[this._orientation + 'ScrollBar'].minScrollPosition = 0			this._updateContent(0, true);			this.update();		}		private function _clearContent():void		{			while (this.__contentContainer.numChildren)			{				this.__contentContainer.removeChildAt(0);			}		}		/**		 * @inheritDoc		 */			override public function update():void		{			if (model)			{				if (this[this._orientation + "ScrollBar"])				{					this[this._orientation + "ScrollBar"].maxScrollPosition = this.model.length - this._numItemsFinallyVisible + 1;				}			}		}		override protected function scrollHandler(e:ScrollEvent):void		{			var pos:Number = Math.round(this[this._orientation + "ScrollPosition"]);			var newPos:Object = {x: this.__contentContainer.x, y: this.__contentContainer.y};			var mask:DisplayObject = this.getScrollMask();						if (!isNaN(pos))			{				if (this.model != null)				{					var target:Number = -this._getItemPositionByIndex(pos);										// Make sure we don't scroll "past" the content.					if (pos >= this.model.length - this._numItemsFinallyVisible)					{						target = Math.max(target, mask[this._widthOrHeight] - this._getItemPositionByIndex(this.model.length - 1) - this._getItemSize(this.model.length - 1));					}					newPos[this._xOrY] = Math.min(0, target);				}			}			this.moveContent(newPos.x, newPos.y);			this.updateContent();		}private function _getItemSize(index:int):Number{	var size:Number = this._sizeCache[index];		if (isNaN(size))	{		var item:Object = this._listItems[index];		if (!item)		{			item = this._getItemFor(index);			item.model = this.model.getItemAt(index);		}		size = item[this._widthOrHeight];		this._sizeCache[index] = size;	}	return size;}private function _getItemPositionByIndex(index:int):Number{	var position:Number = this._positionCache[index];	if (isNaN(position))	{		position = index == 0 ? 0 : this._getItemPositionByIndex(index - 1) + this._getItemSize(index - 1);		this._positionCache[index] = position;	}	return this._positionCache[index];}private function _getItemFor(index:int, markAsUsed:Boolean = false):Object{	var listItem:Object = this._listItems[index];	if (!listItem)	{		if (markAsUsed)			listItem = this._unusedItems.pop();		else			listItem = this._unusedItems[0];	}	if (!listItem)	{trace("CREATING\t" + index);		listItem = new this._itemViewClass();		if (!markAsUsed)			this._unusedItems.push(listItem);	}	return listItem;}private function _updateContent(startIndex:int, firstTime:Boolean = false):void{	if (!firstTime && (startIndex == this._firstVisibleItemIndex))	{		// Already showing the correct units.		return;	}	var listItem:Object;	var tmp:Object;	var index:int = startIndex;	var roomForMore:Boolean = true;	var mask:DisplayObject = this.getScrollMask();	var maskSize:Number = mask[this._widthOrHeight];	var maskY:Number = mask[this._xOrY];	var y:Number = this._getItemPositionByIndex(startIndex);	var container:DisplayObjectContainer = this.getContentContainer();	while ((index < this.model.length) && (y + container[this._xOrY] < maskSize + mask[this._xOrY]))	{		listItem = this._getItemFor(index, true);		this.__contentContainer.addChild(listItem as DisplayObject);		listItem.model = this.model.getItemAt(index);		this._listItems[index] = listItem;		// Don't count the first item because you need enough visible items to fill the viewport as it scrolls out.		if (index != startIndex)		{			y += listItem[this._widthOrHeight];		}		listItem[this._xOrY] = this._getItemPositionByIndex(index);		index++;	}	// Update list of unused items.	for (var p:String in this._listItems)	{		var i:int = parseInt(p);		if (i < startIndex || i > index)		{			listItem = this._listItems[i];			delete this._listItems[i];			this._unusedItems.push(listItem);		}	}/*// FIXME: this needs to be based on what the height would be with all the elements, not what it is!	var contentSize:Number = listItem[this._xOrY] + listItem[this._widthOrHeight];	this[this._orientation + "ScrollBar"].enabled = this.__contentContainer[this._widthOrHeight] > mask[this._widthOrHeight];	if (this[this._orientation + "ScrollPolicy"] == ScrollPolicy.AUTO)	{		this[this._orientation + "ScrollBar"].visible = this[this._orientation + "ScrollBar"].enabled;	}	else	{		this[this._orientation + "ScrollBar"].visible = this[this._orientation + "ScrollPolicy"] == ScrollPolicy.ON;	}*/	// Hide the unused items.	for each (listItem in this._listItems)	{//		listItem.visible = usedItems.indexOf(listItem) != -1;	}	if (firstTime)	{		var numItemsFinallyVisible = index - this[this._orientation + "ScrollPosition"];		this[this._orientation + "ScrollBar"].pageSize = numItemsFinallyVisible;		this[this._orientation + "PageScrollSize"] = numItemsFinallyVisible - 1;		// Determine the number of items that are visible at max scroll position.		var numItems:int = 0;		var combinedSize:Number = 0;		var j:int = this.model.length - 1;		while (combinedSize < maskSize)		{			numItems++;			combinedSize += this._getItemSize(j);			j--;		}		this._numItemsFinallyVisible = numItems;	}	this._firstVisibleItemIndex = startIndex;}		private function _invalidateItemView(index:int):void	{// FIXME: if index >= this.model.length - this._numItemsFinallyVisible, we'll need to do some special stuff. i.e. recalculate _numItems finally visible.		// Clear the cached size.		delete this._sizeCache[index];				// Clear the cache of positions for subsequent items.		for (var i:int = index + 1; i < this.model.length; i++)		{			delete this._positionCache[i];		}	}		/**		 *		 * Updates the contents of the container based on its position.		 *				 */		protected function updateContent():void		{			var container:DisplayObjectContainer = this.getContentContainer();			var mask:DisplayObject = this.getScrollMask();			// Get the index of the first visible item.			var firstVisibleItemIndex:int = 0;			var combinedSize:Number = 0;			var y:Number = container[this._xOrY];			while (container[this._xOrY] + this._getItemPositionByIndex(firstVisibleItemIndex + 1) < mask[this._xOrY])			{				firstVisibleItemIndex++;			}			this._updateContent(firstVisibleItemIndex);		}	}}