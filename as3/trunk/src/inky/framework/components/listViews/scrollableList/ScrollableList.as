package inky.framework.components.listViews.scrollableList{	import inky.framework.collections.*;	import inky.framework.components.scrollPane.views.BaseScrollPane;	import inky.framework.components.scrollBar.ScrollPolicy;	import inky.framework.components.listViews.IListView;//	import inky.framework.components.listViews.IListItemView;	import inky.framework.components.scrollPane.views.IScrollPane;	import inky.framework.controls.*;	import inky.framework.display.IDisplayObject;	import inky.framework.components.scrollBar.events.ScrollEvent;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 *	 *  		 * @author Eric Eldredge	 * @author Rich Perez	 * @author Matthew Tretter	 *	 * @langversion ActionScript 3	 * @playerversion Flash 9.0.0	 *		 */	public class ScrollableList extends BaseScrollPane implements IListView	{		private static var HORIZONTAL:String = "horizontal"; // Should be in another class.		private static var VERTICAL:String = "vertical";				private var __contentContainer:DisplayObjectContainer;		private var _model:IList;		private var _listItems:Object;		private var _itemViewClass:Class;		private var _numItemsFinallyVisible:uint;  // The number of items visible at max scroll position.		private var _orientation:String;		private var _widthOrHeight:String;		private var _xOrY:String;				private var _positionCache:Array;private var _sizeCache:Array;		public function ScrollableList()		{			this._init();		}		private function _init():void		{			if (this.horizontalScrollBar && this.verticalScrollBar)			{// FIXME: should work with both, in case for example items in a vertically oriented list are too wide.				throw new Error("A ScrollableList can have either a horizontal or vertical scroll bar, but not both");			}						if (this.horizontalScrollBar)			{				this._orientation = HORIZONTAL;				this._widthOrHeight = "width";				this._xOrY = "x";			}			else			{				this._orientation = VERTICAL;				this._widthOrHeight = "height";				this._xOrY = "y";			}// FIXME: most of the following probably needs to be in model setter.			this._positionCache = [];			this._sizeCache = [];			this._listItems = {};			this.__contentContainer = this.getContentContainer();			this[this._orientation + 'LineScrollSize'] = 1;		}		/**		 * @inheritDoc		 */		public function get model():IList		{			return this._model;		}		/**		 * @private		 */		public function set model(model:IList):void		{			this._model = model;			this._setContent();		}		/**		 * @inheritDoc		 */		public function get itemViewClass():Class		{			return this._itemViewClass;		}		/**		 * @private		 */		public function set itemViewClass(itemViewClass:Class):void		{			this._itemViewClass = itemViewClass;		}		private function _setContent():void		{			this.addEventListener(Event.ENTER_FRAME, this._setContentNow);		}						private function _setContentNow(e:Event):void		{			e.currentTarget.removeEventListener(e.type, arguments.callee);			this._clearContent();			if (this._model == null) return;			if (this._itemViewClass == null)			{				throw new Error("itemViewClass is not set!");			}			this[this._orientation + 'ScrollBar'].minScrollPosition = 0			this._updateContent(0, true);			this.update();		}		private function _clearContent():void		{			while (this.__contentContainer.numChildren)			{				this.__contentContainer.removeChildAt(0);			}		}		/**		 * @inheritDoc		 */			override public function update():void		{			if (model)			{				if (this[this._orientation + "ScrollBar"])				{					this[this._orientation + "ScrollBar"].maxScrollPosition = this.model.length - this._numItemsFinallyVisible + 1;				}			}		}		override protected function scrollHandler(e:ScrollEvent):void		{			var pos:Number = Math.round(this[this._orientation + "ScrollPosition"]);			var newPos:Object = {x: this.__contentContainer.x, y: this.__contentContainer.y};			var mask:DisplayObject = this.getScrollMask();						if (!isNaN(pos))			{				if (this.model != null)				{					var target:Number = -this._getItemPositionByIndex(pos);										// Make sure we don't scroll "past" the content.					if (pos >= this.model.length - this._numItemsFinallyVisible)					{						trace("m");						target = Math.max(target, mask[this._widthOrHeight] - this._getItemPositionByIndex(this.model.length - 1) - this._getItemSize(this.model.length - 1));					}					newPos[this._xOrY] = Math.min(0, target);				}			}			this.moveContent(newPos.x, newPos.y);		}private function _getItemSize(index:int):Number{	var size:Number = this._sizeCache[index];		if (isNaN(size))	{		var item:Object = this._listItems[index];		if (!item)		{trace("\thad to create\t" + index);// FIXME: try to use unused item first. if you must create, put item into unused item pool to be used later.			item = new this.itemViewClass();			item.model = this.model.getItemAt(index);		}		size = item.height;		this._sizeCache[index] = size;	}	return size;}private function _getItemPositionByIndex(index:int):Number{	var position:Number = this._positionCache[index];	if (isNaN(position))	{		position = index == 0 ? 0 : this._getItemPositionByIndex(index - 1) + this._getItemSize(index - 1);		this._positionCache[index] = position;	}		if (this._positionCache[index] == null) trace("NO CACHED VALUE FOR " + index);	return this._positionCache[index];}private var _firstVisibleItemIndex:int;private function _updateContent(startIndex:int, firstTime:Boolean = false):void{// FIXME: Why did I have to comment this out?	/*if (!firstTime && (startIndex == this._firstVisibleItemIndex))	{		// Already showing the correct units.		return;	}*/	var listItem:Object;	var tmp:Object;	var index:int = startIndex;	var roomForMore:Boolean = true;	var mask:DisplayObject = this.getScrollMask();	var maskSize:Number = mask[this._widthOrHeight];	var maskY:Number = mask[this._xOrY];	var y:Number = this._getItemPositionByIndex(startIndex);	var container:DisplayObjectContainer = this.getContentContainer();	var usedItems:Array = [];	while ((index < this.model.length) && (y + container.y < maskSize + mask.y))	{		listItem = this._listItems[index];				if (listItem == null)		{			// Find one to reuse			for (var j:int = 1; j < this.model.length; j++)			{				var k:int = (this.model.length - j + index + this.model.length) % this.model.length;				tmp = this._listItems[k];				if (tmp != null)				{					var isUsed:Boolean = usedItems.indexOf(tmp) != -1;										if (!isUsed)					{						var p:Point = mask.globalToLocal(tmp.localToGlobal(new Point(0, 0)));						var bottom:Number = p[this._xOrY] + tmp[this._widthOrHeight];						listItem = tmp;						delete this._listItems[k];						break;					}				}			}					// If no item could be reused, make a new one.			if (listItem == null)			{				listItem = new this._itemViewClass();				this.__contentContainer.addChild(listItem as DisplayObject);			}						listItem.model = this.model.getItemAt(index);			this._listItems[index] = listItem;		}		usedItems[index] = listItem;		y += listItem[this._widthOrHeight];		listItem[this._xOrY] = this._getItemPositionByIndex(index);		index++;	}	var contentSize:Number = listItem[this._xOrY] + listItem[this._widthOrHeight];	this[this._orientation + "ScrollBar"].enabled = this.__contentContainer[this._widthOrHeight] > mask[this._widthOrHeight];	if (this[this._orientation + "ScrollPolicy"] == ScrollPolicy.AUTO)	{		this[this._orientation + "ScrollBar"].visible = this[this._orientation + "ScrollBar"].enabled;	}	else	{		this[this._orientation + "ScrollBar"].visible = this[this._orientation + "ScrollPolicy"] == ScrollPolicy.ON;	}	// Hide the unused items.	for each (listItem in this._listItems)	{		listItem.visible = usedItems.indexOf(listItem) != -1;	}	if (firstTime)	{		var numItemsFinallyVisible = index - this[this._orientation + "ScrollPosition"];		this[this._orientation + "ScrollBar"].pageSize = numItemsFinallyVisible;		this[this._orientation + "PageScrollSize"] = numItemsFinallyVisible - 1;		// Determine the number of items that are visible at max scroll position.		var numItems:int = 0;		var combinedSize:Number = 0;		var i:int = this.model.length - 1;		while (combinedSize < mask.height)		{			numItems++;			combinedSize += this._getItemSize(i);			i--;		}		this._numItemsFinallyVisible = numItems;	}	this._firstVisibleItemIndex = startIndex;}		private function _invalidateItemView(index:int):void	{// FIXME: if index >= this.model.length - this._numItemsFinallyVisible, we'll need to do some special stuff. i.e. recalculate _numItems finally visible.		// Clear the cached size.		delete this._sizeCache[index];				// Clear the cache of positions for subsequent items.		for (var i:int = index + 1; i < this.model.length; i++)		{			delete this._positionCache[i];		}	}		/**		 *		 * Updates the contents of the container based on its position.		 *				 */		protected function updateStuff():void		{			var container:DisplayObjectContainer = this.getContentContainer();			var mask:DisplayObject = this.getScrollMask();			// Get the index of the first visible item.			var firstVisibleItemIndex:int = 0;			var combinedSize:Number = 0;			var y:Number = container.y;			while (container.y + this._getItemPositionByIndex(firstVisibleItemIndex + 1) < mask.y)			{				firstVisibleItemIndex++;			}			this._updateContent(firstVisibleItemIndex);		}		override protected function moveContent(x:Number, y:Number):void		{			super.moveContent(x, y);			this.updateStuff();		}	}}