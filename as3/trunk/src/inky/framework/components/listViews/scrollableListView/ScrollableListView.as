package inky.framework.components.listViews.scrollableListView{	import inky.framework.collections.*;	import inky.framework.components.scrollPane.views.BaseScrollPane;	import inky.framework.components.scrollBar.ScrollPolicy;	import inky.framework.components.listViews.IListView;//	import inky.framework.components.listViews.IListItemView;	import inky.framework.components.scrollPane.views.IScrollPane;	import inky.framework.controls.*;	import inky.framework.display.IDisplayObject;	import inky.framework.components.scrollBar.events.ScrollEvent;	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.events.Event;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 *	 *  		 * @author Eric Eldredge	 * @author Rich Perez	 * @author Matthew Tretter	 *	 * @langversion ActionScript 3	 * @playerversion Flash 9.0.0	 *		 */	public class ScrollableListView extends BaseScrollPane implements IListView	{		private static var HORIZONTAL:String = "horizontal"; // Should be in another class.		private static var VERTICAL:String = "vertical";				private var __contentContainer:DisplayObjectContainer;		private var _defaultListItemSize:Number;		private var _model:IList;		private var _listItems:Object;		private var _listItemViewClass:Class;		private var _numItemsInitiallyVisible:uint;		private var _orientation:String;		private var _widthOrHeight:String;		private var _xOrY:String;		public function ScrollableListView()		{			this._init();		}		private function _init():void		{			if (this.horizontalScrollBar && this.verticalScrollBar)			{				throw new Error("A ScrollableListView can have either a horizontal or vertical scroll bar, but not both");			}						if (this.horizontalScrollBar)			{				this._orientation = HORIZONTAL;				this._widthOrHeight = "width";				this._xOrY = "x";			}			else			{				this._orientation = VERTICAL;				this._widthOrHeight = "height";				this._xOrY = "y";			}			this._defaultListItemSize = 0;			this._listItems = {};			this.__contentContainer = this.getContentContainer();//			this.source = this.getContentContainer();			this[this._orientation + 'LineScrollSize'] = 1;		}		/**		 * @inheritDoc		 */		public function get model():IList		{			return this._model;		}		/**		 * @private		 */		public function set model(model:IList):void		{			this._model = model;			this._setContent();		}		/**		 * @inheritDoc		 */		public function get listItemViewClass():Class		{			return this._listItemViewClass;		}		/**		 * @private		 */		public function set listItemViewClass(listItemViewClass:Class):void		{			this._listItemViewClass = listItemViewClass;		}		private function _setContent():void		{			this.addEventListener(Event.ENTER_FRAME, this._setContentNow);		}						private function _setContentNow(e:Event):void		{			e.currentTarget.removeEventListener(e.type, arguments.callee);			this._clearContent();			if (this._model == null) return;			if (this._listItemViewClass == null)			{				throw new Error("listItemViewClass is not set!");			}			this[this._orientation + 'ScrollBar'].minScrollPosition = 0			this._updateContent(0, true);			this.update();		}		private function _clearContent():void		{			while (this.__contentContainer.numChildren)			{				this.__contentContainer.removeChildAt(0);			}		}		/**		 * @inheritDoc		 */			override public function update():void		{			if (model)			{				if (this[this._orientation + "ScrollBar"])				{					this[this._orientation + "ScrollBar"].maxScrollPosition = this.model.length - this._numItemsInitiallyVisible + 1;				}			}		}		override protected function scrollHandler(e:ScrollEvent):void		{			var pos:Number = Math.round(this[this._orientation + "ScrollPosition"]);			var newPos:Object = {x: this.__contentContainer.x, y: this.__contentContainer.y};			var mask:DisplayObject = this.getScrollMask();						if (!isNaN(pos))			{//!// this should happen after the conent is moved so that we can accurately determine if items are shown. but how can we move the content without knowing the things in it? (namely, their size)// You need to move the content to know which elements will still be within the mask.// But how do you know what to move it to without updating the content?				this._updateContent(pos);				/*var listItem:DisplayObject = this._listItems[verticalPosition];				var p:Point;				if (listItem)				{					// If the item exists in the list.					p = this.__contentContainer.globalToLocal(listItem.localToGlobal(new Point(0, 0)));					var bounds:Rectangle = this.__contentContainer.getBounds(this.__contentContainer);					y = Math.min(0, -Math.min(p.y - mask.y, bounds.height + bounds.y - mask.height));				}*/if (this.model != null)newPos[this._xOrY] = Math.min(0, -Math.min(this._defaultListItemSize * pos, this._defaultListItemSize * this.model.length - mask[this._widthOrHeight]));			}			this.moveContent(newPos.x, newPos.y);		}private var _firstVisibleItemIndex:int;private function _updateContent(startIndex:int, firstTime:Boolean = false):void{	if (!firstTime && (startIndex == this._firstVisibleItemIndex))	{		// Already showing the correct units.		return;	}	var listItem:Object;	var tmp:Object;	var index:int = startIndex;	var roomForMore:Boolean = true;	var usedItems:Object = [];	var combinedSize:Number = 0;	var mask:DisplayObject = this.getScrollMask();	var maskSize:Number = mask[this._widthOrHeight];	var maskY:Number = mask[this._xOrY];	while ((index < this.model.length) && (combinedSize < maskSize))	{//trace("LOOKING FOR VIEW FOR\t\t\t" + index);		listItem = this._listItems[index];				if (listItem == null)		{			// Find one to reuse			for (var j:int = 1; j < this.model.length; j++)			{				var k:int = (this.model.length - j + index + this.model.length) % this.model.length;				tmp = this._listItems[k];//trace('\t' + k + '?');				if (tmp != null)				{					var isUsed:Boolean = usedItems.indexOf(tmp) != -1;										if (!isUsed)					{						var p:Point = mask.globalToLocal(tmp.localToGlobal(new Point(0, 0)));						var bottom:Number = p[this._xOrY] + tmp[this._widthOrHeight];//						var isShowing:Boolean = (p.y + tmp.height > 0) && (p.y < maskSize + maskY);var isShowing:Boolean = false;						if (!isShowing)						{//trace("\t\tREUSING\t" + k);							listItem = tmp;							delete this._listItems[k];							break;						}//else trace("\tCANT RESUSE\t" + k + "\tBC\tisShowing");					}//else trace("\tCANT RESUSE\t" + k + "\tBC\tisUsed");				}//else trace("\tCANT RESUSE\t" + k + "\tBC\t" + "null");			}					// If no item could be reused, make a new one.			if (listItem == null)			{//trace("\tCREATING\t" + index);				listItem = new this._listItemViewClass();				this.__contentContainer.addChild(listItem as DisplayObject);				this._defaultListItemSize = listItem[this._widthOrHeight];			}						listItem.model = this.model.getItemAt(index);			this._listItems[index] = listItem;		}		usedItems.push(listItem);		combinedSize += listItem[this._widthOrHeight];		listItem[this._xOrY] = this._defaultListItemSize * index;		index++;	}	var contentSize:Number = listItem[this._xOrY] + listItem[this._widthOrHeight];	this[this._orientation + "ScrollBar"].enabled = this.__contentContainer[this._widthOrHeight] > mask[this._widthOrHeight];	if (this[this._orientation + "ScrollPolicy"] == ScrollPolicy.AUTO)	{		this[this._orientation + "ScrollBar"].visible = this[this._orientation + "ScrollBar"].enabled;	}	else	{		this[this._orientation + "ScrollBar"].visible = this[this._orientation + "ScrollPolicy"] == ScrollPolicy.ON;	}	if (firstTime)	{		var numItemsInitiallyVisible = index - this[this._orientation + "ScrollPosition"];		this[this._orientation + "ScrollBar"].pageSize = numItemsInitiallyVisible;		this[this._orientation + "PageScrollSize"] = numItemsInitiallyVisible - 1;		this._numItemsInitiallyVisible = numItemsInitiallyVisible;	}		this._firstVisibleItemIndex = startIndex;}		protected function updateContent():void		{//			this._updateContent();		}	}}