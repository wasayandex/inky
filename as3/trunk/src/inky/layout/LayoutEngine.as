package inky.layout {	import flash.utils.Dictionary;	import flash.display.DisplayObject;	import flash.display.Stage;	import inky.layout.LayoutComponent;	import flash.events.Event;	import flash.geom.Rectangle;	/**	 *	 *  ..	 *		 * 	@langversion ActionScript 3	 *	@playerversion Flash 9.0.0	 *	 *	@author matthew	 *	@since  2009.07.30	 *	 */	public class LayoutEngine	{		private static var _instance:LayoutEngine;		private var _invalidDisplayListComponents:Array;		private var _invalidPropertiesComponents:Array;		private var _invalidSizeComponents:Array;		private var _isInvalid:Boolean;		private static var _singletonEnforcer:Object = {};		private var _stage:Stage;						/**		 *		 */		public function LayoutEngine(enforcer:Object)		{			if (enforcer != LayoutEngine._singletonEnforcer)				throw new ArgumentError("Get an instance of the LayoutEngine by using LayoutEngine.getInstance()");							this._isInvalid = false;			this._invalidDisplayListComponents = [];			this._invalidPropertiesComponents = [];			this._invalidSizeComponents = [];		}// TODO: stage should not be an argument. it should be discovered automatically like with LayoutUtil.		public static function getInstance(stage:Stage = null):LayoutEngine		{			if (!LayoutEngine._instance)				LayoutEngine._instance = new LayoutEngine(LayoutEngine._singletonEnforcer);if (stage)LayoutEngine._instance._stage = stage;			return LayoutEngine._instance;		}		public function get isInvalid():Boolean		{			return this._isInvalid;		}		/**		 *			 */		public function invalidateDisplayList(component:DisplayObject):void		{			if (this._invalidDisplayListComponents.indexOf(component) == -1)			{				this._invalidDisplayListComponents.push(component);				this._invalidate();			}		}				/**		 *			 */		public function invalidateProperties(component:DisplayObject):void		{			if (this._invalidPropertiesComponents.indexOf(component) == -1)			{				this._invalidPropertiesComponents.push(component);				this._invalidate();			}		}		/**		 *			 */		public function invalidateSize(component:DisplayObject):void		{			if (this._invalidSizeComponents.indexOf(component) == -1)			{				this._invalidSizeComponents.push(component);				this._invalidate();			}		}		/**		 *	Schedules validation for the layout.		 */		private function _invalidate():void		{			if (!this.isInvalid)			{				this._stage.addEventListener(Event.RENDER, this._validate);				this._stage.invalidate();				this._isInvalid = true;			}		}		private function _validate(event:Event):void		{			var i:int;			var len:int;			var component:LayoutComponent;						// Commit phase: call validateProperties on each component in top-down order.			var invalidPropertiesComponents:Array = this._invalidPropertiesComponents.sortOn("nestLevel", Array.NUMERIC);			len = invalidPropertiesComponents.length;			for (i = 0; i < len; i++)			{				component = invalidPropertiesComponents[i];				component.validateProperties();			}						// Measurement phase: call validateSize on each component in bottom-up order.			var invalidSizeComponents:Array = this._invalidSizeComponents.sortOn("nestLevel", Array.NUMERIC).reverse();			len = invalidSizeComponents.length;			for (i = len - 1; i >= 0; i--)			{				component = invalidSizeComponents[i];				var oldBounds:Rectangle = new Rectangle(component.x, component.y, component.width, component.height);				component.validateSize();				var newBounds:Rectangle = new Rectangle(component.x, component.y, component.width, component.height);				if (!oldBounds.equals(newBounds))				{					this.invalidateDisplayList(component);					if (component.parent is LayoutComponent)					{// FIXME: The following line will not cause the size to be validated this sweep because we've already gotten the array. One solution is to have an isValidating boolean and if you invalidate during the validation sweep, add it to a temp array (with nest level indexes) to iterate through after.						this.invalidateSize(component.parent);						this.invalidateDisplayList(component.parent);					}				}			}						// Layout phase: call validateDisplayList on each component in top-down order.			var invalidDisplayListComponents:Array = this._invalidDisplayListComponents.sortOn("nestLevel", Array.NUMERIC);			len = invalidDisplayListComponents.length;			for (i = 0; i < len; i++)			{				component = invalidDisplayListComponents[i];				component.validateDisplayList();			}						// Validation complete. Clear all the invalid lists.			this._invalidDisplayListComponents.length = 0;			this._invalidPropertiesComponents.length = 0;			this._invalidSizeComponents.length = 0;		}	}}